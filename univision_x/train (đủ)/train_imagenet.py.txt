import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision.datasets import ImageFolder
from torchvision import transforms

from classification import UniVisionX_ImageNet
from engine.base_trainer import BaseTrainer
from engine.checkpoint import save_checkpoint


class ImageNetTrainer(BaseTrainer):
    def __init__(self, model, optimizer, scheduler, device):
        super().__init__(model, optimizer, scheduler, device)
        self.criterion = nn.CrossEntropyLoss()

    def train_epoch(self, loader):
        self.model.train()
        total_loss = 0

        for img, label in loader:
            img, label = img.to(self.device), label.to(self.device)

            loss = self.criterion(self.model(img), label)
            self.optimizer.zero_grad()
            loss.backward()
            self.optimizer.step()

            total_loss += loss.item()

        return total_loss / len(loader)


def main():
    device = "cuda" if torch.cuda.is_available() else "cpu"

    tf = transforms.Compose([
        transforms.RandomResizedCrop(224),
        transforms.RandomHorizontalFlip(),
        transforms.ToTensor(),
        transforms.Normalize(
            mean=[0.485,0.456,0.406],
            std=[0.229,0.224,0.225]
        )
    ])

    ds = ImageFolder("imagenet/train", transform=tf)
    loader = DataLoader(ds, batch_size=256, shuffle=True, num_workers=8)

    model = UniVisionX_ImageNet().to(device)
    optimizer = torch.optim.AdamW(model.parameters(), lr=1e-3, weight_decay=0.05)
    scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=300)

    trainer = ImageNetTrainer(model, optimizer, scheduler, device)
    trainer.train(loader, epochs=300)

    save_checkpoint(
        model.backbone, optimizer, 300,
        "weights/univisionx_imagenet_backbone.pth"
    )


if __name__ == "__main__":
    main()
